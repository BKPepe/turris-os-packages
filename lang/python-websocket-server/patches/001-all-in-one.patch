diff --git a/websocket_server/websocket_server.py b/websocket_server/websocket_server.py
index 550099b..a522abd 100644
--- a/websocket_server/websocket_server.py
+++ b/websocket_server/websocket_server.py
@@ -5,6 +5,7 @@ import re, sys
 import struct
 from base64 import b64encode
 from hashlib import sha1
+import logging
 
 if sys.version_info[0] < 3 :
 	from SocketServer import ThreadingMixIn, TCPServer, StreamRequestHandler
@@ -37,23 +38,28 @@ PAYLOAD_LEN = 0x7f
 PAYLOAD_LEN_EXT16 = 0x7e
 PAYLOAD_LEN_EXT64 = 0x7f
 
-OPCODE_TEXT = 0x01
-CLOSE_CONN  = 0x8
-
+OPCODE_CONTINUATION = 0x0
+OPCODE_TEXT         = 0x1
+OPCODE_BINARY       = 0x2
+OPCODE_CLOSE_CONN   = 0x8
+OPCODE_PING         = 0x9
+OPCODE_PONG         = 0xA
 
+# ------------------------------ Logging -------------------------------
+logger = logging.getLogger(__name__)
 
 # -------------------------------- API ---------------------------------
 
-class API():
+class API(object):
 	def run_forever(self):
 		try:
-			print("Listening on port %d for clients.." % self.port)
+			logger.info("Listening on port %d for clients.." % self.port)
 			self.serve_forever()
 		except KeyboardInterrupt:
 			self.server_close()
-			print("Server terminated.")
+			logger.info("Server terminated.")
 		except Exception as e:
-			print("ERROR: WebSocketsServer: "+str(e))
+			logger.error("ERROR: WebSocketsServer: " + str(e), exc_info=True)
 			exit(1)
 	def new_client(self, client, server):
 		pass
@@ -76,60 +82,8 @@ class API():
 
 # ------------------------- Implementation -----------------------------
 
-class WebsocketServer(ThreadingMixIn, TCPServer, API):
-
-	allow_reuse_address = True
-	daemon_threads = True # comment to keep threads alive until finished
 
-	'''
-	clients is a list of dict:
-	    {
-	     'id'      : id,
-	     'handler' : handler,
-	     'address' : (addr, port)
-	    }
-	'''
-	clients=[]
-	id_counter=0
-
-	def __init__(self, port, host='127.0.0.1'):
-		self.port=port
-		TCPServer.__init__(self, (host, port), WebSocketHandler)
-
-	def _message_received_(self, handler, msg):
-		self.message_received(self.handler_to_client(handler), self, msg)
-
-	def _new_client_(self, handler):
-		self.id_counter += 1
-		client={
-			'id'      : self.id_counter,
-			'handler' : handler,
-			'address' : handler.client_address
-		}
-		self.clients.append(client)
-		self.new_client(client, self)
-
-	def _client_left_(self, handler):
-		client=self.handler_to_client(handler)
-		self.client_left(client, self)
-		if client in self.clients:
-			self.clients.remove(client)
-	
-	def _unicast_(self, to_client, msg):
-		to_client['handler'].send_message(msg)
-
-	def _multicast_(self, msg):
-		for client in self.clients:
-			self._unicast_(client, msg)
-		
-	def handler_to_client(self, handler):
-		for client in self.clients:
-			if client['handler'] == handler:
-				return client
-
-
-
-class WebSocketHandler(StreamRequestHandler):
+class WebSocketHandler(StreamRequestHandler, object):
 
 	def __init__(self, socket, addr, server):
 		self.server=server
@@ -157,24 +111,43 @@ class WebSocketHandler(StreamRequestHandler):
 			return bytes
 
 	def read_next_message(self):
-
-		b1, b2 = self.read_bytes(2)
+		try:
+			b1, b2 = self.read_bytes(2)
+		except ValueError as e:
+			b1, b2 = 0, 0
 
 		fin    = b1 & FIN
 		opcode = b1 & OPCODE
 		masked = b2 & MASKED
 		payload_length = b2 & PAYLOAD_LEN
+		opcode_handler = None
 
 		if not b1:
-			print("Client closed connection.")
+			logger.info("Client closed connection.")
 			self.keep_alive = 0
 			return
-		if opcode == CLOSE_CONN:
-			print("Client asked to close connection.")
+		if opcode == OPCODE_CLOSE_CONN:
+			logger.info("Client asked to close connection.")
 			self.keep_alive = 0
 			return
 		if not masked:
-			print("Client must always be masked.")
+			logger.info("Client must always be masked.")
+			self.keep_alive = 0
+			return
+		if opcode == OPCODE_CONTINUATION:
+			logger.info("Continuation frames not handled.")
+			return
+		elif opcode == OPCODE_BINARY:
+			logger.info("Binary frames not handled.")
+			return
+		elif opcode == OPCODE_TEXT:
+			opcode_handler = self.server._message_received_
+		elif opcode == OPCODE_PING:
+			opcode_handler = self.server._ping_received_
+		elif opcode == OPCODE_PONG:
+			opcode_handler = self.server._pong_received_
+		else:
+			logger.info("Unknown opcode %#x." % opcode)
 			self.keep_alive = 0
 			return
 
@@ -188,28 +161,31 @@ class WebSocketHandler(StreamRequestHandler):
 		for char in self.read_bytes(payload_length):
 			char ^= masks[len(decoded) % 4]
 			decoded += chr(char)
-		self.server._message_received_(self, decoded)
+		opcode_handler(self, decoded)
 
 	def send_message(self, message):
 		self.send_text(message)
 
-	def send_text(self, message):
+	def send_pong(self, message):
+		self.send_text(message, OPCODE_PONG)
+
+	def send_text(self, message, opcode=OPCODE_TEXT):
 		'''
 		NOTES
 		Fragmented(=continuation) messages are not being used since their usage
 		is needed in very limited cases - when we don't know the payload length.
 		'''
-	
+
 		# Validate message
 		if isinstance(message, bytes):
 			message = try_decode_UTF8(message) # this is slower but assures we have UTF-8
 			if not message:
-				print("Can\'t send message, message is not valid UTF-8")
+				logger.warning("Can\'t send message, message is not valid UTF-8")
 				return False
 		elif isinstance(message, str) or isinstance(message, unicode):
 			pass
 		else:
-			print('Can\'t send message, message has to be a string or bytes. Given type is %s' % type(message))
+			logger.warning('Can\'t send message, message has to be a string or bytes. Given type is %s' % type(message))
 			return False
 
 		header  = bytearray()
@@ -218,27 +194,33 @@ class WebSocketHandler(StreamRequestHandler):
 
 		# Normal payload
 		if payload_length <= 125:
-			header.append(FIN | OPCODE_TEXT)
+			header.append(FIN | opcode)
 			header.append(payload_length)
 
 		# Extended payload
 		elif payload_length >= 126 and payload_length <= 65535:
-			header.append(FIN | OPCODE_TEXT)
+			header.append(FIN | opcode)
 			header.append(PAYLOAD_LEN_EXT16)
 			header.extend(struct.pack(">H", payload_length))
 
 		# Huge extended payload
 		elif payload_length < 18446744073709551616:
-			header.append(FIN | OPCODE_TEXT)
+			header.append(FIN | opcode)
 			header.append(PAYLOAD_LEN_EXT64)
 			header.extend(struct.pack(">Q", payload_length))
-			
+
 		else:
 			raise Exception("Message is too big. Consider breaking it into chunks.")
 			return
 
 		self.request.send(header + payload)
 
+	def authenticate(message):
+		'''
+		This method is meant to be overriden to inject some authentication mechanism
+		'''
+		return True
+
 	def handshake(self):
 		message = self.request.recv(1024).decode().strip()
 		upgrade = re.search('\nupgrade[\s]*:[\s]*websocket', message.lower())
@@ -249,14 +231,19 @@ class WebSocketHandler(StreamRequestHandler):
 		if key:
 			key = key.group(1)
 		else:
-			print("Client tried to connect but was missing a key")
+			logger.warning("Client tried to connect but was missing a key")
+			self.keep_alive = False
+			return
+		if not self.authenticate(message):
+			logger.warn("Failed to authenticate a client.")
+			self.request.send(self.make_unauthorized_response().encode())
 			self.keep_alive = False
 			return
 		response = self.make_handshake_response(key)
 		self.handshake_done = self.request.send(response.encode())
 		self.valid_client = True
 		self.server._new_client_(self)
-		
+
 	def make_handshake_response(self, key):
 		return \
 		  'HTTP/1.1 101 Switching Protocols\r\n'\
@@ -264,7 +251,10 @@ class WebSocketHandler(StreamRequestHandler):
 		  'Connection: Upgrade\r\n'             \
 		  'Sec-WebSocket-Accept: %s\r\n'        \
 		  '\r\n' % self.calculate_response_key(key)
-		
+
+	def make_unauthorized_response(self):
+		return 'HTTP/1.1 403 Forbidden\r\n\r\n'
+
 	def calculate_response_key(self, key):
 		GUID = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'
 		hash = sha1(key.encode() + GUID.encode())
@@ -275,12 +265,70 @@ class WebSocketHandler(StreamRequestHandler):
 		self.server._client_left_(self)
 
 
+class WebsocketServer(ThreadingMixIn, TCPServer, API):
+
+	allow_reuse_address = True
+	daemon_threads = True # comment to keep threads alive until finished
+
+	'''
+	clients is a list of dict:
+	    {
+	     'id'      : id,
+	     'handler' : handler,
+	     'address' : (addr, port)
+	    }
+	'''
+	clients=[]
+	id_counter=0
+
+	def __init__(self, port, host='127.0.0.1', handler=WebSocketHandler):
+		self.port=port
+		TCPServer.__init__(self, (host, port), handler)
+
+	def _message_received_(self, handler, msg):
+		self.message_received(self.handler_to_client(handler), self, msg)
+
+	def _ping_received_(self, handler, msg):
+		handler.send_pong(msg)
+
+	def _pong_received_(self, handler, msg):
+		pass
+
+	def _new_client_(self, handler):
+		self.id_counter += 1
+		client={
+			'id'      : self.id_counter,
+			'handler' : handler,
+			'address' : handler.client_address
+		}
+		self.clients.append(client)
+		self.new_client(client, self)
+
+	def _client_left_(self, handler):
+		client=self.handler_to_client(handler)
+		self.client_left(client, self)
+		if client in self.clients:
+			self.clients.remove(client)
+
+	def _unicast_(self, to_client, msg):
+		to_client['handler'].send_message(msg)
+
+	def _multicast_(self, msg):
+		for client in self.clients:
+			self._unicast_(client, msg)
+
+	def handler_to_client(self, handler):
+		for client in self.clients:
+			if client['handler'] == handler:
+				return client
+
+
 
 def encode_to_UTF8(data):
 	try:
 		return data.encode('UTF-8')
 	except UnicodeEncodeError as e:
-		print("Could not encode data to UTF-8 -- %s" % e)
+		logger.error("Could not encode data to UTF-8 -- %s" % e)
 		return False
 	except Exception as e:
 		raise(e)
@@ -295,7 +343,7 @@ def try_decode_UTF8(data):
 		return False
 	except Exception as e:
 		raise(e)
-		
+
 
 
 # This is only for testing purposes
